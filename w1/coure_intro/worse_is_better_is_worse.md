reading date: 2024.9.6

one part I think funny is the writer of this paper is the same guy that writes the rise of worse is better.

## the argument about the worse is better is worse in the passage:

### My first rebuttal is that there really isnâ€™t a worse-is-better design philosophy. 
### Second, can anyone really ever achieve the goals of the right thing?There are always tradeoffs in design and implementation, and no project (except Algol 68?) ever really tried to be pure right thing. 
### Third, the best understanding of what is meant by worse is better and the right thing is presented in the PC-losering example, is this a better solution than handing the problem off to the user? The complexity of the right-thing solution is so great that many consider it nearly impossible to get it right
### Fourth, how bad is Unix?For this machine, Unix was the right thing solution.
### Fifth, C is coupled with Unix in the worse-is-better scenario, and can anyone seriously propose Lisp as the right-thing alternative? Lisp, face it, is used for advanced research and development in AI and other esoteric areas.
### Sixth, the role of the host computer as determiner of success has been conveniently ignored in the worse-is-better argument.
### Seventh, as Unix had no rival on the PDP-11 and Vax, neither did C.
### Eighth, C is not obviously a worse language
### Ninth, there has never been a true, important worse-is-better/the-right-thing faceoff, and so no one can point to an actual example of the theory that one has greater survival characteristics than the other.

I think this passage mainly talks to part
one part is, the argument of worse is better itself is wrong:there is never a confront between unix,c and Lisp together with its operating system.since they have different using fields.Also,at that time , Unix and C isn't worse at all compared to other OS and PL.
and also the pc-loser-ring example seems wrong because return a flag to user is the right thing.Also, there was never a design really takes worse is better philosophy and there is no one can really chase do the right thing. there is always compromises!

the other part is the advice of worse is better to students and new developers is corrosive. One shouldn't aim at high and implement 50% of it in the beginning.One should try to get the best at the beginning instead though compromises have to be made.
